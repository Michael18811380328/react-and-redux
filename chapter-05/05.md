## 第五章 React 组件的性能优化

### 单个组件的性能优化

1、使用浏览器测试渲染时间，使用 React Perf 工具对比性能的差距。

2、除非性能出现了问题，不然不要专门花时间优化性能。根据二八定律，我们应该优化很重要的 20% 的性能的问题，忽略 80% 性能不重要的问题。

用什么样的方式定义组件的接口、如何定义 state 和 props，使用什么样的算法比对虚拟 DOM。

性能优化要定量：知道优化前后，是否达到预期的效果。

开发者永远要想到极端情况：例如用户同时新建10000行，同时删除10000行等操作。

React 优化：React 组件更新时，默认执行全部的生命周期函数，执行 render 创建虚拟 DOM。所以通过 shouldComponentUpdate PureComponeent React.memo 这三个函数对组件进行优化。

React-redux 中

```js
export default connect(mapStateToProps, mapDispatchToProps)(Foo);
```

这里使用 connect 已经实现了 shouldComponentUpdate 进行 props 的浅对比，优化了性能。

为什么只实现浅层比较，不实现深层比较？因为对象的属性可能比较深，深层比较可能消耗不少性能。

浅层比较时，对象尽量在组件初始化声明，不要每次 render 时都创建一个新的对象，减少不必要的渲染。

### 多个 React 组件的性能优化

React 首次渲染只渲染一次，主要的性能问题在中间的更新过程中。

这个需要了解 React DIFF 函数的过程（Reconciliation）

- 节点类型不同：直接卸载原始节点，渲染新节点

- 节点类型相同：不卸载原始节点，执行节点内部的生命周期函数，内部重新渲染

- 多个子组件：通过 key 直接比较每个子组件；如果 key 不同，才进行卸载。

所以，这里需要确定 每个组件有唯一的 Key，尽量避免使用 key={index} 这样的写法。

key 和 ref 是保留的特殊的 props，子组件内部不能直接使用这两个属性。

### 使用 reselect 优化性能

但是这个库实际使用量不大，仅供参考。

状态树的设计，应该范式化：让数据只存储一份，维持数据的一致性。

反范式化：利用数据存储的冗余，换取数据的读写效率（读取比较容易，修改比较复杂）。
